"0","extract_modularity_data <- function(communities, graph){"
"0","  # 引数:"
"0","  # communities: igraphのコミュニティオブジェクト"
"0","  # graph: igraphオブジェクト"
"0",""
"0","  mems_list <- list() # メンバーシップの情報が保存されるリスト"
"0","  num_communities <- NA # コミュニティの数が保存されるベクトル"
"0","  modularities <- NA # モジュラリティスコアが保存されるベクトル"
"0",""
"0","  # 集計化の水準（すなわちステップ）を"
"0","  # 階層的マージデータから抽出する."
"0","  num_merges <- 0:nrow(communities$merges)"
"0","  # 初めは全てのノードが自身だけのコミュニティに属していることに対応する"
"0","  # 0から始める。これはマージデータフレームに行を持っていない。"
"0",""
"0","  # それぞれの集計化のレベルを繰り返す"
"0","  for (x in 1:length(num_merges)){"
"0",""
"0","    # 最初にcut_at関数で与えられたマージレベルのメンバーシップ情報を"
"0","    # 抽出する。入力はコミュニティオブジェクトと関心のあるマージ段階。"
"0","    mems_list[[x]] <- cut_at(communities, steps = num_merges[x])"
"0",""
"0","    # そして与えられたクラスタリング解法に紐づいたコミュニティの数を計算する:"
"0","    num_communities[x] <- length(unique(mems_list[[x]]))"
"0",""
"0","    # 当該コミュニティ帰属に対応する値を取得できていることを確かめるために"
"0","    # モジュラリティスコアも計算する:"
"0","    modularities[x] <- modularity(graph, mems_list[[x]])"
"0","    }"
"0",""
"0","  # 抽出した情報をデータフレームにまとめる"
"0","  plot_data <- data.frame(modularity = modularities,"
"0","                          num_communities = num_communities)"
"0",""
"0","  # 小さいコミュニティ数から大きなコミュニティ数になるよう並び替える:"
"0","  mems_list <- mems_list[order(plot_data$num_communities)]"
"0","  plot_data <- plot_data[order(plot_data$num_communities), ]"
"0","  rownames(plot_data) <- 1:nrow(plot_data)"
"0",""
"0","  # 結果をリスト形式で出力:"
"0","  return(list(summary_data = plot_data,"
"0","        membership_list = mems_list))"
"0","}"
