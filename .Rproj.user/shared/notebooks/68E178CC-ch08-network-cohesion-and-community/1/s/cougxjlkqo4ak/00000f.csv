"0","create_subcommunity <- function(graph, initial_communities, community_number){"
"0","  # 引数:"
"0","  # graph: igraphオブジェクト"
"0","  # initial_communities: 元のコミュニティのメンバーシップ"
"0","  # community_number: 対象のコミュニティ番号（つまり、さらに分割したいコミュニティ）"
"0",""
"0","  # ここで、対象のコミュニティだけのサブグラフを作成します"
"0","  in_community <- which(initial_communities == community_number)"
"0","  subgraph1 <- induced_subgraph(graph = graph,"
"0","                               vids = in_community)"
"0",""
"0","  # 次に、サブグラフに対してコミュニティ検出アルゴリズム（fast and greedyを使用）を実行します"
"0","  comm1 <- cluster_fast_greedy(graph = subgraph1)"
"0",""
"0","  # サブグラフ内の各個人のコミュニティメンバーシップを取得します"
"0","  mems_subgraph1 <- membership(comm1)"
"0",""
"0","  # 次に、サブグラフ内のIDを取得し、元の完全なネットワークにマッピングし直せるようにします"
"0","  ids_map <- as.numeric(vertex_attr(subgraph1, ""name""))"
"0",""
"0","  mems_new <- initial_communities # 元のコミュニティを単にコピーします"
"0",""
"0","  # ここで、コミュニティのラベルを付け直し、元の完全なネットワーク上のコミュニティの集合に戻せるようにします。"
"0","  # これらの新しいコミュニティIDが一意であることを保証したいため、元のコミュニティ番号の最大値を取得し、"
"0","  # それをサブグラフのコミュニティIDに加算します。"
"0","  mems_subgraph1_relabel <- mems_subgraph1 + max(initial_communities)"
"0",""
"0","  # ここで、新しいコミュニティを、ネットワーク全体に対応するコミュニティメンバーシップのベクトルに配置します。"
"0","  mems_new[ids_map] <- mems_subgraph1_relabel"
"0","  # 注意：対象のサブグラフ内のものだけを変更します。"
"0",""
"0","  # 必要であれば、すべてのコミュニティのラベルを付け直し、古いコミュニティ番号を削除して、小さい順に並べ替えることができます："
"0","  num_comms_new <- length(unique(mems_new))"
"0","  mems_updated <- as.numeric(as.character(factor(mems_new,"
"0","                                                 labels = 1:num_comms_new)))"
"0",""
"0","  # ここで、サブグラフ、メンバーシップ、そして更新されたコミュニティメンバーシップのベクトルを出力します："
"0","  return(list(subgraph = subgraph1,"
"0","              mems_subgraph = mems_subgraph1,"
"0","              membership_updated = mems_updated))"
"0","}"
